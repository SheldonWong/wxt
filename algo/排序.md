[TOC]

## 冒泡

## 选择排序
思想描述：每次选择未排序部分的最小的元素，将其拼接到排序部分的最后一个位置。

## 插入排序
思想描述：维护一个有序列表和一个无序列表，将无序列表中的元素插入到有序列表合适的位置。

## 归并排序

## 堆排序

## 快速排序

快排思想的形象描述：假设这里有10个人排成一列，我们随便指定一个人，然后让比这个人高的同学站到他的左边，比这个人低
的站到他的右边，再依次对这个人左右两边的人进行上述过程。

快速排序主要分为两个过程，一个是把主元素放到合适的位置，并返回索引，另外一个是递归的完成上述过程。分别对应如下：

- partition
- quicksort

```java
//对arr[l...r]进行partition操作
//返回p使得arr[l+1...j]<arr[p],a[j+1...i]>arr[p]
partition(arr,l,r):
	v = arr[l]

	j = l;
	for i = l+1 to r:
		if(arr[l] < v){
			j++;
			swap(arr,j,i);
		} 

	swap(arr,l,j);
	return j;
quicksort(arr,l,r):
	if(l >= r)
		return;
	int p = partition(arr,l,r);
	quicksort(arr,l,p-1);
	quicksort(arr,p+1,r);

```


## 冒泡排序和选择排序的区别




- 冒泡:

```C 
for i:=1 to n-1 do 
if (a[i]>a[i+1]) then swap(i,i+1);
```

- 选择: 

```C
for i:=1 to n-1 do 
if (a[i]>a[n]) then swap(i,n); 
```

总的来说，两种排序比较的次数是相同的 
但交换的次数，选择排序是更少的 
虽然两者的时间复杂度都是 O(n^2) 
但通常，选择排序更快一点 
冒泡排序是每一次都可能要交换 
而选择排序是在比较时记下a[i]的位置 最后来交换 
所以他们的交换过程是不一样的 而查找的过程是一样的 
效率不会比冒泡的低…